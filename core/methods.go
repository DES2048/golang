package core

import (
	"fmt"
	"math"
)

// методы в go

// методы в Go можно задавать как для структур, так и для
// именованых типов, если их источником не является указатель или интерфейс

// например можно задать именнованому типу метод String() и изменить его вывод
// fmt
type Km float64

// k здесь называется получателем метода и передается в него, как локальная переменная
func (k Km) String() string {
	return fmt.Sprintf("%G km", k)
}

// сам тип Point2d объявлен в struct.go

// в качестве имени получателя, часто выбирают первую букву типа
func (p Point2d) Distance(q Point2d) float64 {
	return math.Hypot(p.X-q.X, p.Y-q.Y)
}

/* Использования указателя в качестве получателя позволяет мутировать
получателя. Также принято, чтое сли у типа есть хоть один метод с получателем-указателем
все остальные методы тоже должны иметь получатель указатель
*/
func (p *Point2d) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}

func MethodsDemo() {
	// чтобы не приходилось брать значение или адрес переменной
	// для вызова метода с нужным типом получателя Go, делает это сам
	p1 := Point2d{2, 2}
	p1.ScaleBy(2)
	fmt.Printf("point after scaling: %v\n", p1)
	// эквивалентно:
	// скобки нужны чтобы адрес брался от p1, а не от результат функции
	(&p1).ScaleBy(2)

	p2 := &Point2d{2, 2}
	// автоматом сделает косв разыменование
	fmt.Printf("distance is %v", p2.Distance(p1))
	// эквивалентно
	(*p2).Distance(*p2)

}

func DemoNilReceiver() {
	/* так как переменные в go инициализируются нулевым значением типа,
	то этот тип является валидным получателем для метода, т.е в методах
	нужно учитывать что вместо указателя на структуру может придти nil и
	мы получим панику, когда попытаемся разыменовать или изменить данные по этому
	указателю
	*/

	var nilPoint *Point2d = nil
	// паника!
	nilPoint.ScaleBy(2)
	//fmt.Println("nil point distance ", nilPoint.Distance(Point2d{1, 1}))
}
