package core

import "fmt"

func ArraysDemo()  {
	// массивы исп редко, так как имеют ограничение по размеру, а в функции и из них
	// часто передаются срезы

	// объявление массива
	var numbers [10]int // массив будет создан и заполнен значениями по умолчанию типа
	fmt.Println(numbers)

	// присвоение осуществляется стандартно
	for i:=0; i < len(numbers); i++ {
		numbers[i] = i+1
	}
	fmt.Println(numbers)

	// для создания массивов тоже можно указать короткую запись
	evens := [5]int{2,4,6,8,10}
	fmt.Println(evens)

	// длину можно заменить ...
	odds := [...]int{1,3,5,7,9}
	fmt.Println(odds)

	// еще можно и так
	nums:=[...]int {
		10,
		9,
		8,
		7, // можно оставлять запятую в конце, удобно когда нужно закоментить элемент
	}
	nums[0]+=1

	// размер массива входит в опр типа, таким образом [3]int и [4]int совершенно разные типы
	// поэтому сравнивать можно только массивы одинаковой длины
	println("evens == odds", evens == odds)

	// также можно иниц некоторые значения массива, а остальные заполнятся знач по умолчанию
	scores := [...]int{5:10, 7:11} // длина возьмется как последний индекс+1
	fmt.Println(scores, len(scores))

	components := [10]int{1:3,5:6} // можно задать длину явно
	fmt.Println("components:", components)
	fmt.Println(cap(components))

	// массив передается в функции ПО ЗНАЧЕНИЮ, поэтому необходимо исп указатели

	// можно создавать указатели на конкретный элемент масссива
	var p = &nums[0]
	fmt.Println("before", nums)
	*p = 100
	fmt.Println("after", nums)

	// range от массива первым значением возвр индекс, а вторым КОПИЮ элемента
	// поэтому нижеследющий код никакого вдияния на массив не окажет
	var zeros = [5]int{}
	for _, v := range zeros {
		v++
	}

	fmt.Println("zeros still zeros:)", zeros)

}
