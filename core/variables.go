package core

import (
	"fmt"
	"os"
)

func VariablesDemo(){
	// переменные объявляются следующим образом
	// var identifier type_def
	var magic int = 65536

	// !!! нельзя создавать переменные которые нигде неиспользуются
	// это приводит к ошибке компиляции
	fmt.Println("magic is", magic)

	// если тип переменной понятен из контекса то его можно опустить
	var welcome = "Welcome!"
	fmt.Println(welcome)

	// также существует сокращенный способ записи через :=
	counter :=5 // тип здесь тоже выводится автоматически

	fmt.Println("counter is", counter)

	// можно разделять объявление и присваивание переменной
	var name string
	name = "Oleg"
	name += name // можно конкатенировать и так
	fmt.Println(name)

	// в go нет понятия неиниц. переменной, если переменная объявляется без присваивания, то она получает
	// значение по умолчанию, в зависимости от типа
	// 	числа: 0
	// 	строка ""
	// 	bool -> false
	// 	ссылочные типы и указатели -> nil
	//  массивы и структуры заполняют свои поля, в зависимости от типов значений полей

	// можно объявить несколько перем в одной строке
	var i, j, k int
	i = i+j+k

	// присвоить им значения
	// количество объявл переменных должно совпадать с количеством присвоений
	// в одной строке можно присваивать данные разных типов
	var one, two, three, success = 1,2,3, true
	success = success && success

	// такое присваивание по сути является кортежным присваиванием как в питоне например
	// можно свопнуть значения например
	// полезно когда нужно присвоить знаечния сразу нескольким переменным
	one, two, three = three, two, one


	// При короткой записи тоже можно присваивать несколько переменных
	s1,s2,s3 := 1,2,3
	s1++
	s2+=s3

	// !!! есть тонкий момент, при коротком групповом присваивании, если одна из переменных уже была объявлена
	// а другая еще нет, то для той которой уже объявлена выполняется операция присваивания, вместо объявления

	f, err := os.Open("sample.txt")
	print(f, err)
	// здесь, так как err уже объявлена, то ей просто присвоится значение
	// сделано это как раз для удобства вызова таких вот функций
	// но для того чтобы это произошло у out должно уст новое значение
	out, err := os.Open("out.txt")
	print(out)

	// еще один способ объявить нексолько переменных сразу
	var (
		user_name = "oleg"
		age = 31
		email = "oleg@mail.ru"
	)

	fmt.Println("name:", user_name, "age:", age, "email:", email)
}
